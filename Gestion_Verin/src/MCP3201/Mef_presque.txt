library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_1164.all;

entity Gestion_MCP3201 is
  port (
    clk : in std_logic;
    Raz_n : in std_logic;
    Data_in : in std_logic;
    Angle_barre : out std_logic_vector(11 downto 0);
    Clk_adc : out std_logic;
    Cs_n : out std_logic
    --strt_conv : out std_logic
  );
end Gestion_MCP3201;

architecture Behavioral of Gestion_MCP3201 is
  signal s_clk_adc, s_clk_adc_RE, s_clk_adc_FE : std_logic;
  signal conv_state : std_logic;
  signal start_conv : std_logic;
  signal enable_count : std_logic := '0';
  signal s_data : std_logic_vector(11 downto 0);
  type State_Type is (Idle, Reading);
  signal c_State, n_State : State_Type;

begin

  -- MEF
  Gestion_State : process (clk, Raz_n)
  begin
    if (Raz_n = '1') then
      c_State <= Idle;
    elsif rising_edge(clk) then
      c_State <= n_State;
    end if;
  end process;

  pilote_adc : process (clk, c_State, conv_state, start_conv, enable_count)
  begin

    case c_State is
      when Idle =>
        if (start_conv = '1') then
          n_State <= Reading;
        else
          enable_count <= '0';
          n_State <= Idle;
        end if;
      when Reading =>
        if conv_state = '1' then
          --s_data <= ((others => '0') );
          --start_conv <= '0';
          n_State <= Idle;
        else
          enable_count <= '1';
          n_State <= Reading;
        end if;
    end case;
  end process;
  enable_count <= '1' when (c_State = Reading) else '0';

  compt_fronts : process (s_clk_adc_RE, Raz_n, enable_count)
    variable count_fronts : integer range 0 to 14 := 0;
  begin
    if (Raz_n = '1') then
      conv_state <= '1';
    elsif s_clk_adc_RE = '1' then
      if enable_count = '1' then
        if (count_fronts = 14) then
          count_fronts := 0;
          conv_state <= '1';
        else
          count_fronts := count_fronts + 1;
          conv_state <= '0';
        end if;
      else
        count_fronts := 0;
        conv_state <= '0';
      end if;
      
    end if;

  end process;
  Cs_n <= not enable_count;

  ------------------------------------------------------------------------
  rec_dec : process (s_clk_adc_RE, Raz_n)
  begin
    if (Raz_n = '1') then
      s_data <= (others => '0');
      Angle_barre <= (others => '0');
    elsif (s_clk_adc_RE = '1') then
      if (conv_state = '0') then
        s_data <= std_logic_vector(shift_left(unsigned(s_data), 1));
        s_data(0) <= Data_in;
      elsif (conv_state = '1') then
        Angle_barre <= s_data;
      end if;

    end if;
  end process;
  ------------------------------------------------------------------------
  gene_1M : process (clk, Raz_n)
    variable count : integer range 0 to 25 := 0;-- utiliser les unsigned plutot que les integer
  begin
    if (Raz_n = '1') then
      s_clk_adc <= '0';
    elsif rising_edge(clk) then
      if count = 25 then
        count := 0;
        if s_clk_adc = '0' then
          s_clk_adc_RE <= '1';
        end if;
        if s_clk_adc = '1' then
          s_clk_adc_FE <= '1';
        end if;
        s_clk_adc <= not s_clk_adc;
      else
        s_clk_adc_RE <= '0';
        s_clk_adc_FE <= '0';
        count := count + 1;
      end if;
    end if;
  end process;
  Clk_adc <= s_clk_adc;
  -------------------------------------------------------------------------
  gene_start_conv : process (clk, Raz_n)
    --generer d'un signal chaque 100ms
    variable count_conv : integer range 0 to 4999999 := 0;
  begin
    if (Raz_n = '1') then
      start_conv <= '1';
    elsif rising_edge(clk) then
      if count_conv = 4999999 then
        start_conv <= '1';
        count_conv := 0;
      else
        --start_conv <= '0';
        count_conv := count_conv + 1;
        start_conv <= '0';
      end if;
    end if;
  end process;
  --strt_conv <= start_conv;
end Behavioral;